# Обновленный промпт для AI-агента: доработка ExcelFlow после коммита "оптимизация2"

```
Доработай приложение ExcelFlow после последних изменений в коммите "оптимизация2" от 13 ноября 2025.

## Контекст

После выполнения оптимизаций приложение успешно обрабатывает большие файлы (6295 строк) с использованием chunking по 1000 строк, но выявлены критические проблемы:

1. **Ошибка импорта pandas** при сохранении результата
2. **Алгоритмы точного сопоставления не работают** — все уровни дают 0 совпадений
3. **Все записи отправляются на ручную проверку** из-за неработающих Уровней 1 и 2

## Лог последнего запуска

```
python3 main.py --input "Материалы/СК_ТПХпродажи_1_пг_2025.xlsx" --output "output_test.xlsx"
```

Результат:
- Обработано 6295/6295 строк (100%)
- **Уровень 1: найдено 0 совпадений** (все 7 частей)
- **Уровень 2: найдено 0 совпадений** (все 7 частей)
- **Размытое сопоставление: 0 совпадений** (ограничено до 10 записей на часть)
- **Ошибка при сохранении:** `NameError: name 'pd' is not defined` (строка 97 в main.py)

## Критические задачи

### 1. Исправить импорт pandas (КРИТИЧЕСКИ ВАЖНО)

**Проблема:** В main.py строка 97 использует `pd.notna()` и `pd.NaT`, но pandas не импортирован.

**Решение:**
```
# В начале main.py после других импортов добавить:
import pandas as pd
```

**Проверить использование pandas в:**
- main.py (строка 97 и другие)
- processors/data_loader.py
- processors/parser.py
- processors/matcher.py

### 2. Исправить алгоритмы сопоставления (КРИТИЧЕСКИ ВАЖНО)

**Проблема:** Уровень 1 и Уровень 2 дают 0 совпадений на всех 6295 записях, что означает полную поломку логики точного сопоставления.

**Что проверить в processors/matcher.py:**

#### А. Уровень 1 (сопоставление по дате и номенклатуре)
```
# Проверить нормализацию номенклатуры
# Убедиться, что в целевой и справочной таблицах используется одинаковая нормализация:
nomenclature_normalized = str(value).strip().lower().replace('  ', ' ')

# Проверить сопоставление периодов
# Дата приобретения должна попадать в период из справочника
# Например: дата 15.01.2025 должна совпасть с "Январь 2025 г."
```

#### Б. Уровень 2 (сопоставление по коду номенклатуры)
```
# Проверить регулярные выражения для извлечения кодов
# Из ТЗ: r'([А-ЯЁ]+\.?\d+\.?\d+\.?\d+(?:-\d+)?)'
# Пример кодов: "ОНГ.216.00.000-01-032", "МШГРП.114.015"

# Убедиться, что коды извлекаются корректно из обеих таблиц
```

**Добавить DEBUG-логирование для диагностики:**
```
# В начале функции сопоставления для первых 3 записей:
if idx < 3:
    logger.debug(f"Запись {idx}:")
    logger.debug(f"  Исходная номенклатура: {original_nomenclature}")
    logger.debug(f"  Нормализованная: {normalized_nomenclature}")
    logger.debug(f"  Извлеченная дата: {acquisition_date}")
    logger.debug(f"  Квартал: {quarter}")
    logger.debug(f"  Код номенклатуры: {nomenclature_code}")
    logger.debug(f"  Кандидатов в справочнике: {len(candidates)}")
```

### 3. Оптимизировать блок сохранения результата

**В main.py (примерно строки 90-110):**

```
# Безопасная обработка дат
try:
    for row_idx, row_data in df_result.iterrows():
        # Форматируем дату приобретения
        acquisition_date = row_data.get('Дата приобретения')
        
        if acquisition_date is not None and pd.notna(acquisition_date) and acquisition_date is not pd.NaT:
            try:
                date_str = acquisition_date.strftime('%d.%m.%Y')
            except:
                date_str = '*Дата не найдена*'
        else:
            date_str = '*Дата не найдена*'
            
        ws.cell(row=row_idx + 2, column=start_col, value=date_str)
        ws.cell(row=row_idx + 2, column=start_col + 1, value=row_data.get('Квартал приобретения', ''))
        ws.cell(row=row_idx + 2, column=start_col + 2, value=row_data.get('Рассчитанная себестоимость', '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'))
        
except Exception as e:
    logger.error(f"Ошибка при записи строки {row_idx}: {e}")
    raise
```

### 4. Улучшить логирование и отчётность

**Добавить после успешного сохранения:**
```
import os

logger.info(f"Файл успешно сохранен: {args.output}")
logger.info(f"Размер файла: {os.path.getsize(args.output) / 1024 / 1024:.2f} МБ")
logger.info("Обработка завершена успешно!")
```

**Улучшить логирование статистики:**
```
# Вывести детальную статистику по каждому типу совпадений
logger.info(f"Детальная статистика совпадений:")
logger.info(f"  - Уровень 1 (дата + номенклатура): {stats['level1_matches']}")
logger.info(f"  - Уровень 2 (код + контрагент): {stats['level2_matches']}")
logger.info(f"  - Размытое сопоставление: {stats['fuzzy_matches']}")
logger.info(f"  - Требует ручной проверки: {stats['manual_checks']}")
logger.info(f"  - Отсутствуют данные: {stats['missing_data']}")
```

### 5. Проверить парсинг дат и периодов

**В processors/parser.py:**

```
# Убедиться, что даты извлекаются корректно
# Из документа: "Реализация товаров и услуг 00КА-000135 от 20.01.2025 23:59:59"
# Должно извлекаться: datetime(2025, 1, 20)

# Проверить парсинг периода из справочника
# "Январь 2025 г." → должен конвертироваться в диапазон [2025-01-01, 2025-01-31]
# Чтобы дата 20.01.2025 попадала в этот период
```

**В utils/date_extractor.py:**
- Проверить регулярное выражение для извлечения дат
- Убедиться, что обрабатываются разные форматы

### 6. Создать тестовый сценарий для проверки

**Создать файл test_matching.py:**
```
import pandas as pd
from processors.parser import DataParser
from processors.matcher import DataMatcher
from utils.logger_config import setup_logger

# Создать тестовые данные с заведомо известным совпадением
test_target = pd.DataFrame({
    'Номенклатура закупки': ['Башмак колонный вращающийся БК-Вр.114'],
    'Документ приобретения': ['Реализация товаров и услуг 00КА-000135 от 20.01.2025'],
    # ... другие необходимые столбцы
})

test_source = pd.DataFrame({
    'Номенклатура завода': ['Башмак колонный вращающийся БК-Вр.114'],
    'Период месяц': ['Январь 2025 г.'],
    'Прямая СС на ед': [15000.50],
    # ... другие необходимые столбцы
})

# Запустить парсер и matcher
logger = setup_logger('DEBUG')
parser = DataParser(logger)
matcher = DataMatcher(logger)

# Обработать и проверить результат
# Ожидаемый результат: найдено 1 совпадение на Уровне 1
```

## Проверка результата

После всех исправлений запустить:
```
python3 main.py --input "Материалы/СК_ТПХпродажи_1_пг_2025.xlsx" --output "output_test.xlsx" --log-level DEBUG
```

**Ожидаемый результат:**
- ✅ Файл создан без ошибок
- ✅ Уровень 1: найдено > 0 совпадений (хотя бы 10-20% от записей с датами)
- ✅ Уровень 2: найдено > 0 совпадений (хотя бы 5-10% от записей без дат)
- ✅ Требует ручной проверки: < 90% (в идеале < 50%)
- ✅ В логе: "Обработка завершена успешно!"
- ✅ output_test.xlsx содержит 3 новых столбца с корректными данными

## Приоритет задач

1. **КРИТИЧЕСКИЙ (срочно):** Добавить `import pandas as pd` в main.py
2. **КРИТИЧЕСКИЙ (срочно):** Исправить нормализацию и сопоставление в matcher.py
3. **ВЫСОКИЙ:** Добавить DEBUG-логирование для диагностики сопоставления
4. **ВЫСОКИЙ:** Исправить обработку дат при сохранении
5. **СРЕДНИЙ:** Улучшить логирование итоговой статистики
6. **ЖЕЛАТЕЛЬНО:** Создать тестовый сценарий для проверки совпадений

