#
Переработай существующее приложение ExcelFlow 
#
**Проблема:** Приложение реализовано с неверной трактовкой требований — создаёт 3 столбца вместо 5, использует формат "Q1" вместо "1 квартал 2024", не заполняет данные из столбцов AQ и AS, неправильная приоритизация.

## КРИТИЧЕСКИЕ изменения, которые необходимо внести

### 1. Изменить количество выходных столбцов (КРИТИЧНО)

**Текущая реализация (НЕВЕРНО):**
- 3 столбца:
  1. Дата приобретения
  2. Квартал приобретения (формат Q1, Q2, Q3, Q4)
  3. Рассчитанная себестоимость (только AR)

**Требуемая реализация:**
- 5 столбцов:
  1. Дата приобретения
  2. Квартал приобретения (формат "N квартал YYYY")
  3. Стоимость закупки НЧТЗ 1 ед (из столбца AQ)
  4. Прямая СС НЧТЗ 1 ед (из столбца AR)
  5. НР НЧТЗ 1 ед (из столбца AS)

**Что нужно сделать:**

В `main.py` в блоке сохранения результата:
```python
# Добавляем заголовки 5 новых столбцов
ws.cell(row=1, column=start_col, value="Дата приобретения")
ws.cell(row=1, column=start_col + 1, value="Квартал приобретения")
ws.cell(row=1, column=start_col + 2, value="Стоимость закупки НЧТЗ 1 ед")
ws.cell(row=1, column=start_col + 3, value="Прямая СС НЧТЗ 1 ед")
ws.cell(row=1, column=start_col + 4, value="НР НЧТЗ 1 ед")

# Заполняем данные
for row_idx, row_data in df_result.iterrows():
    # ... (дата и квартал как раньше)
    ws.cell(row=row_idx + 2, column=start_col + 2, value=row_data.get('Стоимость закупки НЧТЗ 1 ед', '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'))
    ws.cell(row=row_idx + 2, column=start_col + 3, value=row_data.get('Прямая СС НЧТЗ 1 ед', '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'))
    ws.cell(row=row_idx + 2, column=start_col + 4, value=row_data.get('НР НЧТЗ 1 ед', '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'))
``````

В `processors/matcher.py` при успешном сопоставлении:
```
# Вместо одного значения из AR добавляем все три
result_row['Стоимость закупки НЧТЗ 1 ед'] = matched_record['AQ']  # Столбец AQ
result_row['Прямая СС НЧТЗ 1 ед'] = matched_record['AR']          # Столбец AR
result_row['НР НЧТЗ 1 ед'] = matched_record['AS']                 # Столбец AS
``````

### 2. Исправить формат квартала приобретения (КРИТИЧНО)

**Текущая реализация (НЕВЕРНО):**
```python
quarter = f"Q{(month - 1) // 3 + 1}"
# Результат: "Q1", "Q2", "Q3", "Q4"
``````

**Требуемая реализация:**
```
quarter_num = (month - 1) // 3 + 1
year = acquisition_date.year
quarter = f"{quarter_num} квартал {year}"
# Результат: "1 квартал 2025", "4 квартал 2024"
``````

**Примеры:**
- 11.10.2024 → "4 квартал 2024"
- 29.08.2024 → "3 квартал 2024"
- 15.02.2025 → "1 квартал 2025"

**Что нужно сделать:**

В `processors/parser.py` функция определения квартала:
```python
def determine_quarter(date_value):
    """Определяет квартал по дате в формате 'N квартал YYYY'"""
    if date_value is None or pd.isna(date_value):
        return ""
    
    month = date_value.month
    year = date_value.year
    quarter_num = (month - 1) // 3 + 1
    
    return f"{quarter_num} квартал {year}"
``````

### 3. Расширить парсинг форматов документов приобретения

**Текущая реализация (НЕПОЛНАЯ):**
```
# Только "Реализация товаров и услуг"
pattern = r'от\s+(\d{2}\.\d{2}\.\d{4})(?:\s+(\d{2}:\d{2}:\d{2}))?'
``````

**Требуемая реализация:**
```python
# Поддержка всех трёх форматов
patterns = [
    r'Приобретение товаров и услуг.*?от\s+(\d{2}\.\d{2}\.\d{4})(?:\s+(\d{1,2}:\d{2}:\d{2}))?',
    r'Внутренняя накладная.*?от\s+(\d{2}\.\d{2}\.\d{4})(?:\s+(\d{1,2}:\d{2}:\d{2}))?',
    r'Реализация товаров и услуг.*?от\s+(\d{2}\.\d{2}\.\d{4})(?:\s+(\d{1,2}:\d{2}:\d{2}))?'
]
``````

**Примеры документов:**
- "Приобретение товаров и услуг 00КА-001861 от 28.06.2024 0:00:00"
- "Внутренняя накладная 00КА-000054 от 31.12.2023 23:59:59"
- "Реализация товаров и услуг 00КА-000135 от 20.01.2025 23:59:59"

**Что нужно сделать:**

В `utils/date_extractor.py`:
```
def extract_date_from_document(document_text):
    """Извлекает дату из различных форматов документов"""
    if not document_text or pd.isna(document_text):
        return None
    
    patterns = [
        r'Приобретение товаров и услуг.*?от\s+(\d{2}\.\d{2}\.\d{4})',
        r'Внутренняя накладная.*?от\s+(\d{2}\.\d{2}\.\d{4})',
        r'Реализация товаров и услуг.*?от\s+(\d{2}\.\d{2}\.\d{4})'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, str(document_text))
        if match:
            date_str = match.group(1)
            try:
                return datetime.strptime(date_str, '%d.%m.%Y')
            except ValueError:
                continue
    
    return None
``````

### 4. Расширить регулярные выражения для кодов номенклатуры

**Текущая реализация (НЕПОЛНАЯ):**
```python
# Не покрывает сложные числовые коды
patterns = [
    r'[А-ЯЁ]+\.\d+\.\d+\.\d+(?:-\d+)?',
    r'\d+\.\d+\.\d+(?:-\d+)*'
]
``````

**Требуемая реализация:**
```
# Покрытие всех форматов включая "0.0.0-0-0.0-0-32.23.0-28"
patterns = [
    r'[А-ЯЁ]+\.\d+\.\d+\.\d+(?:-\d+)*',           # ОНГ.216.00.000-01-032
    r'[А-ЯЁ]+\.\d+\.\d+(?:-[\d\.,]+)*',           # МШГРП.114.015-032-60,00
    r'\d+\.\d+\.\d+(?:-.*)?',                     # 0.0.0-0-0.0-0-32.23.0-28 (любое продолжение)
    r'[А-ЯЁ]{2,4}-[А-ЯЁ]{2,4}\.\d+'              # БК-Вр.114
]
``````

**Что нужно сделать:**

В `processors/parser.py`:
```python
def extract_nomenclature_code(nomenclature_text):
    """Извлекает код номенклатуры из названия"""
    if not nomenclature_text:
        return None
    
    patterns = [
        r'[А-ЯЁ]+\.\d+\.\d+\.\d+(?:-\d+)*',
        r'[А-ЯЁ]+\.\d+\.\d+(?:-[\d\.,]+)*',
        r'\d+\.\d+\.\d+(?:-.*)?',  # Ключевое изменение — поддержка сложных кодов
        r'[А-ЯЁ]{2,4}-[А-ЯЁ]{2,4}\.\d+'
    ]
    
    for pattern in patterns:
        match = re.search(pattern, nomenclature_text)
        if match:
            return match.group(0)
    
    return None
``````

### 5. Исправить приоритизацию при множественных совпадениях (КРИТИЧНО)

**Текущая реализация (НЕВЕРНО):**
```
# При равных условиях — выбрать с наименьшей стоимостью закупки
candidates = sorted(candidates, key=lambda x: x['AQ'])
``````

**Требуемая реализация:**
```python
# При равных условиях — выбрать с НАИБОЛЬШЕЙ ценой закупки
candidates = sorted(candidates, key=lambda x: x['AQ'], reverse=True)
``````

**Полная приоритизация:**
1. Все три параметра (номенклатура + контрагент + период)
2. Номенклатура + период
3. Код + период
4. Наиболее близкая дата (±7 дней)
5. **НАИБОЛЬШАЯ** цена закупки (не наименьшая!)

**Что нужно сделать:**

В `processors/matcher.py`:
```
def prioritize_candidates(candidates, target_date=None):
    """Выбирает лучшего кандидата по приоритету"""
    
    # Уровень 1: Все три параметра
    level1 = [c for c in candidates if c['score']['all_three']]
    if level1:
        return sorted(level1, key=lambda x Уровень 2: Номенклатура + период
    level2 = [c for c in candidates if c['score']['nomenclature_period']]
    if level2:
        return sorted(level2, key=lambda x: x['AQ'], reverse=True)
    
    # Уровень 3: Код + период
    level3 = [c for c in candidates if c['score']['code_period']]
    if level3:
        return sorted(level3, key=lambda x: x['AQ'], reverse=True)
    
    # Уровень 4: Близость даты
    if target_date:
        level4 = sorted(candidates, key=lambda x: abs((x['date'] - target_date).days))
        closest = [c for c in level4 if abs((c['date'] - target_date).days) <= 7]
        if closest:
            return sorted(closest, key=lambda x: x['AQ'], reverse=True)
    
    # Уровень 5: Наибольшая цена закупки
    return sorted(candidates, key=lambda x: x['AQ'], reverse=True)
``````

### 6. Обновить обработку несопоставленных записей

При отсутствии совпадения заполнять **все три новых столбца** маркером:

```python
if not matched:
    result_row['Стоимость закупки НЧТЗ 1 ед'] = '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'
    result_row['Прямая СС НЧТЗ 1 ед'] = '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'
    result_row['НР НЧТЗ 1 ед'] = '*ТРЕБУЕТ РУЧНОЙ ПРОВЕРКИ*'
``````

### 7. Обновить тестовые сценарии

Добавить тесты для:
- Формата квартала "N квартал YYYY"
- Заполнения всех 5 столбцов
- Всех трёх форматов документов
- Сложных кодов номенклатуры
- Приоритизации с наибольшей ценой

```
def test_quarter_format():
    """Тест корректного формата квартала"""
    date = datetime(2024, 10, 11)
    quarter = determine_quarter(date)
    assert quarter == "4 квартал 2024"

def test_five_columns_created():
    """Тест создания 5 столбцов"""
    # ... проверка наличия всех 5 столбцов в результате

def test_complex_code_extraction():
    """Тест извлечения сложного кода"""
    nomenclature = "Деталь 0.0.0-0-0.0-0-32.23.0-28"
    code = extract_nomenclature_code(nomenclature)
    assert code == "0.0.0-0-0.0-0-32.23.0-28"

def test_prioritization_highest_price():
    """Тест приоритизации по наибольшей цене"""
    candidates = [
        {'AQ': 1000, 'score': {'all_three': True}},
        {'AQ': 2000, 'score': {'all_three': True}}
    ]
    best = prioritize_candidates(candidates)
    assert best['AQ'] == 2000  # Выбран с наибольшей ценой
``````

### 8. Обновить документацию

Синхронизировать DOCUMENTATION.md, README.md и USER_GUIDE.md с новыми требованиями:
- 5 столбцов вместо 3
- Формат квартала "N квартал YYYY"
- Расширенные форматы документов и кодов
- Исправленная приоритизация

## Порядок выполнения

1. **Сначала:** Исправить формирование выходных столбцов (main.py, matcher.py)
2. **Затем:** Изменить формат квартала (parser.py)
3. **После:** Расширить парсинг документов и кодов (date_extractor.py, parser.py)
4. **Далее:** Исправить приоритизацию (matcher.py)
5. **В конце:** Обновить тесты и документацию

## Критерии приёмки

После переработки:
- ✅ Приложение создаёт ровно 5 новых столбцов
- ✅ Квартал имеет формат "N квартал YYYY"
- ✅ Все три столбца (AQ, AR, AS) корректно заполняются данными
- ✅ Поддерживаются все три формата документов
- ✅ Извлекаются сложные коды типа "0.0.0-0-0.0-0-32.23.0-28"
- ✅ При множественных совпадениях выбирается запись с наибольшей ценой закупки
- ✅ Все тесты проходят успешно
- ✅ Документация синхронизирована с реализацией

## Тестирование

Запустить на реальном файле:
```bash
python main.py --input "Материалы/СК_ТПХпродажи_1_пг_2025.xlsx" --output "output_corrected.xlsx" --log-level DEBUG
``````

Проверить результат:
- 5 новых столбцов в конце таблицы
- Квартал в формате "4 квартал 2024"
- Заполненные значения из AQ, AR, AS
- Корректная статистика совпадений

